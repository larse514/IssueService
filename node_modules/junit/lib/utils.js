"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _yaku = require("yaku");

var _yaku2 = _interopRequireDefault(_yaku);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var report = function report(formatAssertErr, actual, expected) {
    return _yaku2.default.reject(formatAssertErr(actual, expected));
};

var isArray = function isArray(json) {
    return json && (typeof json === "undefined" ? "undefined" : _typeof(json)) === "object" && typeof json.length === "number";
};

var getNames = function getNames(json) {
    var names = [];
    if (json && (typeof json === "undefined" ? "undefined" : _typeof(json)) === "object") {
        for (var name in json) {
            names.push(name);
        }
    }
    return names;
};

var isPureObj = function isPureObj(json) {
    return json && (typeof json === "undefined" ? "undefined" : _typeof(json)) === "object" && !isArray(json);
};

var getLen = function getLen(json) {
    return isArray(json) ? json.length : getNames(json).length;
};

var nextPath = function nextPath(path, next) {
    return path === "" ? next : path + "." + next;
};

var joinRes = function joinRes(res, json1, json2, path) {
    return res ? { pass: true } : { pass: false, path: path, json1: json1, json2: json2 };
};

// used as an unique object for exception
var $maxDepthErr = {};

var _eq = function _eq(json1, json2, depthCountdown) {
    var path = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];

    if (depthCountdown === 0) {
        return $maxDepthErr;
    }
    var isBothArr = isArray(json1) && isArray(json2);
    var isBothObj = isPureObj(json1) && isPureObj(json2);

    var json = getLen(json1) > getLen(json2) ? json1 : json2;
    if (isBothArr) {
        for (var i = 0; i < json.length; i++) {
            var eqRes = _eq(json1[i], json2[i], depthCountdown - 1, nextPath(path, i));
            if ($maxDepthErr === eqRes) return $maxDepthErr;
            if (!eqRes.pass) return eqRes;
        }
    } else if (isBothObj) {
        for (var name in json) {
            var eqRes = _eq(json1[name], json2[name], depthCountdown - 1, nextPath(path, name));
            if ($maxDepthErr === eqRes) return $maxDepthErr;
            if (!eqRes.pass) return eqRes;
        }
    } else if (json1 !== json2) {
        return joinRes(false, json1, json2, path);
    }

    return joinRes(true);
};

function spread(fn) {
    return function (args) {
        return fn.apply(null, args);
    };
}

function asyncWrap(fn) {
    fn = spread(fn);
    return function () {
        return _yaku2.default.all(arguments).then(fn);
    };
}

exports.default = {
    extend: function extend(obj, src) {
        for (var key in src) {
            obj[key] = src[key];
        }
        return obj;
    },

    isArray: isArray,

    eq: function eq(formatAssertErr) {
        return asyncWrap(function (actual, expected) {
            var depthCountdown = arguments.length <= 2 || arguments[2] === undefined ? 7 : arguments[2];

            var eqRes = _eq(actual, expected, depthCountdown);
            if (eqRes === $maxDepthErr) {
                var errText = "Maximum recursion depth exceeded: " + depthCountdown;
                return report(formatAssertErr, errText, errText);
            }
            if (eqRes.pass) return _yaku2.default.resolve();

            return report(formatAssertErr, actual, expected);
        });
    }
};